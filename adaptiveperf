#!/bin/bash
set -e

TO_PROFILE=$1

function convert_from_ns_to_us() {
    while read -ra arr; do
	new_val=$(perl <<< "print ${arr[-1]}/1000")
	arr[-1]=$new_val
	echo ${arr[@]}
    done
}

function perf_record() {
    mkdir results/$RESULT_STORAGE/out
    RESULT_OUT=$(pwd)/results/$RESULT_STORAGE/out

    mkfifo $RESULT_OUT/waitpipe

    # stdout and stderr redirection based on https://unix.stackexchange.com/a/6431
    # PID retrieval based on https://stackoverflow.com/a/3786955
    (cat $RESULT_OUT/waitpipe > /dev/null && $TO_PROFILE & echo $! >&3) 3>pid | tee $RESULT_OUT/stdout.log 3>&1 1>&2 2>&3 | tee $RESULT_OUT/stderr.log &
    TO_PROFILE_PID=$(<pid)
    rm -f pid

    SYSCALL_LIST="syscalls:sys_exit_execve,syscalls:sys_exit_clone,syscalls:sys_exit_fork,syscalls:sys_exit_vfork,syscalls:sys_enter_exit,syscalls:sys_enter_exit_group"

    if [[ $(sudo perf list | grep syscalls:sys_exit_clone3 | wc -l) -gt 0 ]]; then
        SYSCALL_LIST+=",syscalls:sys_exit_clone3"
    fi

    sudo perf record -e $SYSCALL_LIST -o $RESULT_OUT/syscalls.data --pid=$TO_PROFILE_PID &
    SYSCALLS_PID=$!
    sudo perf record --call-graph fp -e task-clock -F $1 --off-cpu -o $RESULT_OUT/perf.data --pid=$TO_PROFILE_PID &
    SAMPLING_PID=$!

    echo "==> Waiting 10 seconds for the tracers to warm up..."
    sleep 10

    echo "==> Executing the code..."
    echo 1 > $RESULT_OUT/waitpipe
    wait $SYSCALLS_PID
    wait $SAMPLING_PID

    rm $RESULT_OUT/waitpipe

    sudo chown $(whoami) $RESULT_OUT/*.data

    echo "==> Code execution completed!"
}

if ! grep -qs '/sys/kernel/debug ' /proc/mounts; then
    echo "==> /sys/kernel/debug is not mounted, mounting..."
    sudo mount -t debugfs none /sys/kernel/debug
fi

echo "==> Updating kernel settings to facilitate profiling..."
sudo sysctl kernel.perf_event_paranoid=-1
sudo sysctl kernel.perf_event_max_stack=1024

echo "==> Preparing results directory..."
printf -v DATE "%(%Y_%m_%d_%H_%M)T" -1  # Based on https://stackoverflow.com/a/1401495
RESULT_STORAGE=${DATE}_$(hostname)_$(basename $TO_PROFILE | cut -f1 -d ' ')
mkdir -p results/$RESULT_STORAGE

echo "==> Starting tracers..."
perf_record $3

echo "==> Cleaning up and creating collapsed reports..."
cd results/$RESULT_STORAGE
mv out/*.data .

JOBS=$2
perf script -i perf.data -F comm,tid,pid,time,event,ip,sym,dso,period --no-demangle --max-stack=$(sysctl -n kernel.perf_event_max_stack) --per-event-dump

cat perf.data.task-clock.dump perf.data.offcpu-time.dump | c++filt -p | adaptiveperf-split-report $JOBS
rm *.dump

PIDS=()
for i in $(seq 0 $((JOBS-1))); do
   script_i="script${i}.data"
   echo -n "Starting $script_i..."
   cat $script_i | adaptiveperf-stackcollapse --tid | convert_from_ns_to_us > ${script_i:0:-5}_collapsed.data && rm $script_i && echo "$script_i done!" &
   PIDS+=($!)
   echo "PID ${PIDS[-1]}"
done

for pid in ${PIDS[@]}; do
   wait $pid
done

adaptiveperf-merge script*_collapsed.data > script_collapsed.data.tmp
rm script*_collapsed.data
mv script_collapsed.data.tmp script_collapsed.data

echo "==> Splitting reports into processes/threads..."
cd ../..
adaptiveperf-split-ids results/$RESULT_STORAGE/script_collapsed.data

echo "==> Removing leftover files and producing flame graphs..."
rm results/$RESULT_STORAGE/script*.data
cd results/$RESULT_STORAGE/processed

for i in *.data; do
    adaptiveperf-flamegraph --title="Wall time flame graph" --countname=us "$i" > "${i:0:-5}.svg"
done

echo "==> All finished! You can check the results directory now."
