#!/bin/bash
set -e

TO_PROFILE=$(realpath $1)

function convert_from_ns_to_us() {
    while read -ra arr; do
	new_val=$(perl <<< "print ${arr[-1]}/1000")
	arr[-1]=$new_val
	echo ${arr[@]}
    done
}

function perf_record() {
    mkdir results/out
    RESULT_OUT=$(pwd)/results/out
    OLD_DIR=$(pwd)

    cd $(dirname $TO_PROFILE)
    mkfifo $RESULT_OUT/waitpipe

    # stdout and stderr redirection based on https://unix.stackexchange.com/a/6431
    # PID retrieval based on https://stackoverflow.com/a/3786955
    (cat $RESULT_OUT/waitpipe > /dev/null && $TO_PROFILE & echo $! >&3) 3>pid | tee $RESULT_OUT/stdout.log 3>&1 1>&2 2>&3 | tee $RESULT_OUT/stderr.log &
    TO_PROFILE_PID=$(<pid)

    sudo perf record -e syscalls:sys_exit_execve,syscalls:sys_exit_clone,syscalls:sys_exit_clone3,syscalls:sys_exit_fork,syscalls:sys_exit_vfork,syscalls:sys_enter_exit,syscalls:sys_enter_exit_group -o $RESULT_OUT/syscalls.data --pid=$TO_PROFILE_PID &
    SYSCALLS_PID=$!
    sudo perf record --call-graph fp -e task-clock -F $1 --off-cpu -o $RESULT_OUT/perf.data --pid=$TO_PROFILE_PID &
    SAMPLING_PID=$!

    echo "==> Waiting 10 seconds for the tracers to warm up..."
    sleep 10

    echo "==> Executing the code..."
    echo 1 > $RESULT_OUT/waitpipe
    wait $SYSCALLS_PID
    wait $SAMPLING_PID

    rm $RESULT_OUT/waitpipe

    sudo chown $(whoami) $RESULT_OUT/*.data
    cd $OLD_DIR

    echo "==> Code execution completed!"
}

if ! grep -qs '/sys/kernel/debug ' /proc/mounts; then
    echo "==> /sys/kernel/debug is not mounted, mounting..."
    sudo mount -t debugfs none /sys/kernel/debug
fi

echo "==> Updating kernel settings to facilitate profiling..."
sudo sysctl kernel.perf_event_paranoid=-1
sudo sysctl kernel.perf_event_max_stack=1024

echo "==> Preparing results directory..."
rm -rf results
mkdir results

echo "==> Starting tracers..."
perf_record $3

echo "==> Cleaning up and creating collapsed reports..."
cd results
mv out/*.data .

JOBS=$2
perf script -i perf.data -F comm,tid,pid,time,event,ip,sym,dso,period --no-demangle --max-stack=$(sysctl -n kernel.perf_event_max_stack) --per-event-dump

cat perf.data.task-clock.dump perf.data.offcpu-time.dump | c++filt -p | split_report $JOBS
rm *.dump

PIDS=()
for i in $(seq 0 $((JOBS-1))); do
   script_i="script${i}.data"
   echo -n "Starting $script_i..."
   cat $script_i | stackcollapse-perf.pl --tid | convert_from_ns_to_us > ${script_i:0:-5}_collapsed.data && rm $script_i && echo "$script_i done!" &
   PIDS+=($!)
   echo "PID ${PIDS[-1]}"
done

for pid in ${PIDS[@]}; do
   wait $pid
done

merge script*_collapsed.data > script_collapsed.data.tmp
rm script*_collapsed.data
mv script_collapsed.data.tmp script_collapsed.data

echo "==> Splitting reports into processes/threads..."
cd ..
split_ids results/script_collapsed.data

echo "==> Removing leftover files and producing flame graphs..."
rm results/script*.data
cd results/processed

for i in *.data; do
    flamegraph.pl --countname=us "$i" > "${i:0:-5}.svg"
done

echo "==> All finished! You can check the results directory now."
