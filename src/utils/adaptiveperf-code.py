#!/bin/env python3
import sys
import argparse
import json
import zipfile
from pathlib import Path


paths_file_help = \
    'path to a code paths file generated by AdaptivePerf\n' \
    '(usually as code_paths.lst) or written manually with\n' \
    'one source code file path per line (use "-" for stdin)'
output_help = \
    'path to an output ZIP archive to be produced (src.zip\n' \
    'in the current directory by default, use "-" for stdout)'
verbose_help = \
    'print path-processing-related errors to stderr (these\n' \
    'are not printed by default)'


def run(paths_file, output, verbose):
    paths = []

    def process_src_line(filename, i, line):
        try:
            src_path = Path(line).resolve(strict=True)
        except OSError:
            if verbose:
                print(f'Line {i} in {filename}: Could not resolve '
                      f'{line}, is it a correct and existing path?',
                      file=sys.stderr)
            return

        if src_path.is_dir():
            if verbose:
                print(f'Line {i} in {filename}: {line} refers to a directory',
                      file=sys.stderr)
            return

        paths.append((line, src_path))

    if paths_file == '-':
        for i, line in enumerate(sys.stdin, start=1):
            process_src_line('stdin', i, line.strip())
    else:
        p = Path(paths_file)

        if not p.exists():
            print('adaptiveperf-code: error: ' + paths_file + ' does not exist',
                  file=sys.stderr)
            return 1
        elif p.is_dir():
            print('adaptiveperf-code: error: ' + paths_file + ' is a directory',
                  file=sys.stderr)
            return 1

        with p.open(mode='r') as f:
            for i, line in enumerate(f, start=1):
                process_src_line(paths_file, i, line.strip())

    if output == '-':
        output = sys.stdout.buffer

    with zipfile.ZipFile(output, mode='w',
                         compression=zipfile.ZIP_DEFLATED,
                         compresslevel=9) as zip:
        index = {}

        for i, (orig_path, path) in enumerate(paths):
            name = str(i) + path.suffix
            zip.write(path, name)
            index[orig_path] = name

        zip.writestr('index.json', json.dumps(index) + '\n')

    return 0


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='adaptiveperf-code',
        description='Profiled code packaging tool for AdaptivePerf',
        formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('paths_file', metavar='PATHS_FILE',
                        help=paths_file_help)
    parser.add_argument('-o', dest='out',
                        metavar='FILE', help=output_help,
                        default='src.zip')
    parser.add_argument('-v', dest='verbose',
                        action='store_true', help=verbose_help)
    args = parser.parse_args()

    output_already_existed = False

    if args.out == '-':
        p_out = None
    else:
        p_out = Path(args.out)

    if p_out is not None and p_out.exists():
        output_already_existed = True

    try:
        sys.exit(run(args.paths_file, args.out, args.verbose))
    except KeyboardInterrupt:
        print('adaptiveperf-code: Interrupted', file=sys.stderr)
        if p_out is not None and not output_already_existed \
           and p_out.exists():
            p_out.unlink()
        sys.exit(2)
    except Exception as e:
        if p_out is not None and not output_already_existed \
           and p_out.exists():
            p_out.unlink()
        raise e
